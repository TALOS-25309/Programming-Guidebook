# Programming Guidelines

## 1. 객체지향 프로그래밍을 기반으로 코드를 작성한다.
객체지향 프로그래밍 (OOP)는 다양한 부분에서 큰 이점을 제공한다. 다형성 (Polymorphism), 캡슐화 (Encapsulation), 상속 (Inheritance), 그리고 추상화 (Abstraction)을 달성함으로써,
코드를 더욱 간결하고, 체계적으로 작성할 수 있으며, 오류를 빠르게 찾을 수 있도록 하고, 실수를 예방할 수 있다.

절차 지향적으로 모든 명령을 하나의 함수 안에 나열하는 것은 코드의 복잡성을 기하급수적으로 키워 유지보수 및 디버깅이 사실상 불가능한 코드로 이어진다.
로봇은 언뜻 보면 간단해보여도, 다양한 부분들이 서로 상호작용하는 복잡한 시스템이다. 따라서 체계적으로 Class 구조를 나누고, 객체지향 프로그래밍의 다양한 이점들을 최대한 활용해야한다.

### 1.1. Class는 최대한 세분화한다.
하나의 Class는 단 하나의 역할을 해야한다. 너무 많은 기능을 할당하면 Class의 복잡성이 증가하고, 결국 유지보수에 어려움을 겪게 된다. 
Class 각각의 역할을 명확히 하고, 역할을 세분화하여, Class를 단순하게 유지하고, Class 내부에 선언되는 변수와 함수의 개수를 적절히 유지해야한다.

> e.g. Single Part Class → Part Main Class + Part Constants Class + Part Command Class + Part Adjustment Class

*ref : [FTC 2024-2025 Robot Controller for APOC](https://github.com/TALOS-25309/FTC2024-2025_RobotController_V2) - Part Class Structure*

### 1.2. 자주 사용되는 기능은 반드시 class로 객체화하여 제공한다.
자주 사용되는 기능은 사용할 때 마다 굳이 새로 구현할 필요가 없다. 이렇게 하면 코드가 복잡해지고, 수정이 어려워지며, 버그에 취약한 코드가 만들어진다.
반복적으로 사용되는 기능은 이를 포함하는 Class를 제작하여, Class에서 해당 기능을 구현하고, 외부에서는 Class의 멤버 함수 호출을 통해 해당 기능을 간단히 제어할 수 있도록 추상화 하는 것이 매우 중요하다.

> e.g. PID Control은 대부분의 DC Motor 제어에 필수적으로 필요한 기능이다. 따라서 PID Controller를 커스텀 DC Motor Class에 정의하면, 외부에서는 간단한 함수 호출 하나만으로 PID 제어를 구현할 수 있다.

### 1.3. 상속 시에 "틀"이 필요하면 Interface를, "공유하는 기능"이 필요하면 Class를 활용한다.
상속은 불필요한 기능의 재구현을 막고, 다형성을 달성할 수 있다는 점에서 매우 유용하지만, 코드의 명확성과 가독성을 심하게 떨어트릴 수 있기에, 조심히 사용할 필요가 있다.

Class에 필수적으로 선언되어야 하는 함수와 변수를 강제하기 위한 Class의 "틀"을 제작하는 것이 목적이라면 Class 대신에 Interface로 제작해야한다.
Interface는 함수의 정의가 문법적으로 불가능하기에 모호성과 가독성을 떨어트리지 않고, 함수 정의를 강제함으로써 명확성을 증가시키며, 다형성을 활용할 수 있도록 하는 등 많은 장점을 포함한다.

하지만 만약 Class들이 공통적으로 가져야 할 기능을 존재한다면, Interface로 제작할 수 없기에, Parent Class를 제작해야한다.
단, Parent Class를 제작할 시에는 Child Class에서 정의되어야 하는 함수는 Abstract 함수로 명시적으로 표현해야하며,
Child Class는 Parent Class의 함수를 Override 할 경우, 이를 Annotation으로 명시적으로 표현해야한다.

> e.g. Part Interface 제작을 통해 init, update, stop 함수 등의 정의를 강제하고, 다형성을 활용해 OpMode에서 반복문으로 모든 Part의 명령을 일괄적으로 처리

> e.g. Adjustment Parent Class를 제작하고, FTC Dashboard에서의 공통된 동작은 Parent Class에 구현하고, 각 동작에 따라 Part별로 제공되어야 하는 기능은 Abstract 함수로 Part의 Adjustment Class에서 직접 정의하도록 함

*ref : [FTC 2024-2025 Robot Controller for APOC](https://github.com/TALOS-25309/FTC2024-2025_RobotController_V2) - Part Class Structure & Adjustment Class Structure*

### 1.4. 접근 제한자를 체계적으로 활용한다.
JAVA는 Class의 멤버 함수와 멤버 변수의 외부 접근을 정교하게 조절할 수 있는 다양한 접근 제한자 (Access Modifier)를 가지고 있다.

* __Private__ : 반드시 Class 내부에서만 사용되어야 하는 함수와 변수는 Private로 선언해야함. 부작용을 막기 위해 모든 변수는 Private로 선언하는 것을 권장하며, Getter와 Setter를 활용할 것을 권장함.
* __Default__ : Class의 복잡성을 줄이기 위해 특정 Class를 여러 부분으로 나누어 하나의 Package 안에 모아둔 경우, 분리된 Class들 사이의 보다 더 유기적이고 직접적인 제어가 가능하도록 해야하는 경우가 있음. 이 경우에는 Private 대신에 Default로 선언하여 분리된 Class가 서로의 기능을 바로바로 활용할 수 있도록 해야함.
* __Protected__ : 상속 관계로 이루어진 Class드의 경우, Child Class에서 Parent Class의 함수 혹은 변수를 직접적으로 활용해야하는 경우가 있음. 이 경우에는 Private 대신에 Protected로 선언하여 Child Class에 Parent Class의 기능을 바로바로 활용할 수 있도록 해야함.
* __Public__ : 외부에서 호출되어야 하는 멤버 함수, 그리고 FTC Dashboard에서 값을 바로 수정할수 있도록 선언된 각종 상수들은 Public으로 선언되어야 함.

접근 제한자를 사용할 떄에는 그 접근 제한자를 사용한 **합당한 이유**가 존재하야함. 단순히 편하게 코딩하기 위하여 모든 멤버 함수와 멤버 변수를 Public 등 불필요하게 외부에서 쉽게 접근할 수 있도록 한다면, 코드가 복잡해지고, 일관성이 없어지며,
예상치 못한 부작용이 발생하여 디버깅을 매우 어렵게 만들 수 있다. 외부의 접근 권한이 필요하지 않은 모든 멤버 함수와 멤버 변수는 반드시 Private으로 선언해야하며, 상황에 따라 Default, Protected, Public을 제한적으로 사용해야한다.

간단히 정리하면, Default는 패키지 내의 유기적 연결을 위해 접근 허용이 필요한 경우, Protected는 상속 관계에서 유기적 연결을 위해 접근 허용이 필요한 경우, Public은 외부에서 해당 Class를 사용하기 위해 선언된 멤버 함수에만 사용되어야 한다.

## 2. 하나의 파일에하는 하나의 Class만 작성한다.

## 3. Subclass는 그 구조가 간단해야한다.

## 4. 함수는 하나의 기능만 수행해야하며, 내용이 간결해야한다.

## 5. 상태를 저장하기 위해서는 상수 대신에 Enumeration을 활용한다.
상태 저장은 매우 중요하다. 로봇의 현재 상태를 적절히 나누고, 각 상태를 적절히 표현할 수 있다면, 비정상적인 움직임을 시스템적으로 제한할 수 있고, 독립된 동작을 연결 동작으로 자동화하여 로봇 조작을 더욱 간단하게 만들 수 있다.

각 상태를 저장할 때에는 상수 대신에 Enumeration을 활용한 명시적 저장을 권장한다. 왜냐하면, 상수를 활용할 경우 가독성이 매우 떨어지며, 실수로 인해 잘못된 판단 및 버그가 발생할 수 있기 때문이다.
Enumeration은 자연어를 활용한 상태 정의를 가능하게 하며, 이를 활용해 더욱 명확한 상태 정의 및 상태 기반 제어를 할 수 있다.

상태를 나누는 것 역시나 매우 중요하다. 상태를 불필요하게 세세하게 나누면, 상태 기반 제어에서 조건이 매우 길고 복잡하게 변할 수 있다.
반대로 상태를 너무 간단하게 나누면, 상태 기반 제어가 부정확해지고, 예상치 못한 작동이 발생할 수 있다.

이를 예방하기 위하여 상태는 상태 기반 제어를 고려하여 최소한으로 나누어야한다.

*ref : [FTC 2024-2025 Robot Controller for APOC](https://github.com/TALOS-25309/FTC2024-2025_RobotController_V2) - Part States & TeleOpMode State Based Control*

## 6. Sleep은 절대 사용하지 않는다.
Robot Controller를 만들다보면 특정 딜레이 이후 명령을 수행해야하는 경우가 있다. 일반적으로는 Sleep을 활용해서 딜레이를 넣지만, Robot Controller 개발을 할 때에는 절대 Sleep을 사용하면 안 된다.

로봇은 반복문 속에서 끊임없이 게임패드와 각종 센서의 상태를 확인하고, 이를 활용한 적절한 제어가 이루어져야한다. 하지만 Sleep 함수를 사용하여 딜레이를 넣는 순간, 그 딜레이 동안에는 모든 로봇 제어가 정지된다.
만약 로봇이 가만히 있는 상황이었다면 아무런 상관이 없겠으나, DC Motor가 돌아가고 있던 상황이아면, PID 제어 혹은 게임 패드 제어에 의거한 DC Motor 속도 조작이 중단되고, 멈추어햐 할 때 멈추지 않고 계속해서 움직이는 사고가 일어날 수 있다.
이는 로봇에 매우 심각한 손상을 일으킬 수 있는 중대한 버그이다. 

따라서 우리는 Sleep 함수를 사용하면 안 되며, 딜레이를 주어야 하는 경우, 딜레이 이후 실행할 명령을 함수형 프로그래밍 관점에서 함수 객체의 형태로 저장해두고 실행을 미루었다가,
내부적으로 타이머를 활용해서 주어진 딜레이에 해당하는 시간이 지난 시점을 지속적으로 검사하여, 특정 딜레이 이후에 해당 기능을 실행하는 방식으로 구현해야 한다. 
이 경우 타이머를 활용해 주어진 딜레이에 해당하는 시간이 지났는지 확인하는 동시에, 계속해서 반복문을 돌리며, 입력값에 대한 지속적인 출력값 피드백이 가능하다.

이 방식을 구현한 대표적인 방법이 바로 FTC 2024-2025 Into The Deep Season Robot Controller 코드의 Schedule 객체이다.
구현되어있는 코드를 직접 읽고 학습하여 그 구조를 파악하는 것을 권장한다.

또한, 이 방법을 응용하면, 딜레이 뿐만 아니라, 특정 조건을 만족했을 때 코드가 실행되도록 할 수도 있다.
이를 통해 딜레이 기반이 아니라, 동작 종료를 기반으로 한 실행을 통해 동작을 최적화할 수 있다.

*ref : [FTC 2024-2025 Robot Controller for APOC](https://github.com/TALOS-25309/FTC2024-2025_RobotController_V2) - Features / Schedule*

## 7. 수치들은 단위를 통일한다.

## 8. 수식은 코드로 바로 작성하지 않는다.

## 9. Telemetry를 활용한 값 출력은 코드 어디서든 가능해야한다.

## 10. Git & Github을 활용한 버전 관리를 체계적으로 수행한다.
