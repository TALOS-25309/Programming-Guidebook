# Programming Guidelines

## 1. 객체지향 프로그래밍을 기반으로 코드를 작성한다.
객체지향 프로그래밍 (OOP)는 다양한 부분에서 큰 이점을 제공한다. 다형성 (Polymorphism), 캡슐화 (Encapsulation), 상속 (Inheritance), 그리고 추상화 (Abstraction)을 달성함으로써,
코드를 더욱 간결하고, 체계적으로 작성할 수 있으며, 오류를 빠르게 찾을 수 있도록 하고, 실수를 예방할 수 있다.

절차 지향적으로 모든 명령을 하나의 함수 안에 나열하는 것은 코드의 복잡성을 기하급수적으로 키워 유지보수 및 디버깅이 사실상 불가능한 코드로 이어진다.
로봇은 언뜻 보면 간단해보여도, 다양한 부분들이 서로 상호작용하는 복잡한 시스템이다. 따라서 체계적으로 Class 구조를 나누고, 객체지향 프로그래밍의 다양한 이점들을 최대한 활용해야한다.

### 1.1. Class는 최대한 세분화한다.
하나의 Class는 단 하나의 역할을 해야한다. 너무 많은 기능을 할당하면 Class의 복잡성이 증가하고, 결국 유지보수에 어려움을 겪게 된다. 
Class 각각의 역할을 명확히 하고, 역할을 세분화하여, Class를 단순하게 유지하고, Class 내부에 선언되는 변수와 함수의 개수를 적절히 유지해야한다.

> e.g. Single Part Class → Part Main Class + Part Constants Class + Part Command Class + Part Adjustment Class

*ref : [FTC 2024-2025 Robot Controller for APOC](https://github.com/TALOS-25309/FTC2024-2025_RobotController_V2/tree/main/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/part) - Part Class Structure*

### 1.2. 자주 사용되는 기능은 반드시 class로 객체화하여 제공한다.
자주 사용되는 기능은 사용할 때 마다 굳이 새로 구현할 필요가 없다. 이렇게 하면 코드가 복잡해지고, 수정이 어려워지며, 버그에 취약한 코드가 만들어진다.
반복적으로 사용되는 기능은 이를 포함하는 Class를 제작하여, Class에서 해당 기능을 구현하고, 외부에서는 Class의 멤버 함수 호출을 통해 해당 기능을 간단히 제어할 수 있도록 추상화 하는 것이 매우 중요하다.

> e.g. PID Control은 대부분의 DC Motor 제어에 필수적으로 필요한 기능이다. 따라서 PID Controller를 커스텀 DC Motor Class에 정의하면, 외부에서는 간단한 함수 호출 하나만으로 PID 제어를 구현할 수 있다.

### 1.3. 상속 시에 "틀"이 필요하면 Interface를, "공유하는 기능"이 필요하면 Class를 활용한다.
상속은 불필요한 기능의 재구현을 막고, 다형성을 달성할 수 있다는 점에서 매우 유용하지만, 코드의 명확성과 가독성을 심하게 떨어트릴 수 있기에, 조심히 사용할 필요가 있다.

Class에 필수적으로 선언되어야 하는 함수와 변수를 강제하기 위한 Class의 "틀"을 제작하는 것이 목적이라면 Class 대신에 Interface로 제작해야한다.
Interface는 함수의 정의가 문법적으로 불가능하기에 모호성과 가독성을 떨어트리지 않고, 함수 정의를 강제함으로써 명확성을 증가시키며, 다형성을 활용할 수 있도록 하는 등 많은 장점을 포함한다.

하지만 만약 Class들이 공통적으로 가져야 할 기능을 존재한다면, Interface로 제작할 수 없기에, Parent Class를 제작해야한다.
단, Parent Class를 제작할 시에는 Child Class에서 정의되어야 하는 함수는 Abstract 함수로 명시적으로 표현해야하며,
Child Class는 Parent Class의 함수를 Override 할 경우, 이를 Annotation으로 명시적으로 표현해야한다.

> e.g. Part Interface 제작을 통해 init, update, stop 함수 등의 정의를 강제하고, 다형성을 활용해 OpMode에서 반복문으로 모든 Part의 명령을 일괄적으로 처리

> e.g. Adjustment Parent Class를 제작하고, FTC Dashboard에서의 공통된 동작은 Parent Class에 구현하고, 각 동작에 따라 Part별로 제공되어야 하는 기능은 Abstract 함수로 Part의 Adjustment Class에서 직접 정의하도록 함

*ref : [FTC 2024-2025 Robot Controller for APOC](https://github.com/TALOS-25309/FTC2024-2025_RobotController_V2/tree/main/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/part) - Part Class Structure & Adjustment Class Structure*

### 1.4. 접근 제한자를 체계적으로 활용한다.
JAVA는 Class의 멤버 함수와 멤버 변수의 외부 접근을 정교하게 조절할 수 있는 다양한 접근 제한자 (Access Modifier)를 가지고 있다.

* __Private__ : 반드시 Class 내부에서만 사용되어야 하는 함수와 변수는 Private로 선언해야함. 부작용을 막기 위해 모든 변수는 Private로 선언하는 것을 권장하며, Getter와 Setter를 활용할 것을 권장함.

* __Default__ : Class의 복잡성을 줄이기 위해 특정 Class를 여러 부분으로 나누어 하나의 Package 안에 모아둔 경우, 분리된 Class들 사이의 보다 더 유기적이고 직접적인 제어가 가능하도록 해야하는 경우가 있음. 이 경우에는 Private 대신에 Default로 선언하여 분리된 Class가 서로의 기능을 바로바로 활용할 수 있도록 해야함.

* __Protected__ : 상속 관계로 이루어진 Class드의 경우, Child Class에서 Parent Class의 함수 혹은 변수를 직접적으로 활용해야하는 경우가 있음. 이 경우에는 Private 대신에 Protected로 선언하여 Child Class에 Parent Class의 기능을 바로바로 활용할 수 있도록 해야함.

* __Public__ : 외부에서 호출되어야 하는 멤버 함수, 그리고 FTC Dashboard에서 값을 바로 수정할수 있도록 선언된 각종 상수들은 Public으로 선언되어야 함.

접근 제한자를 사용할 떄에는 그 접근 제한자를 사용한 **합당한 이유**가 존재하야함. 단순히 편하게 코딩하기 위하여 모든 멤버 함수와 멤버 변수를 Public 등 불필요하게 외부에서 쉽게 접근할 수 있도록 한다면, 코드가 복잡해지고, 일관성이 없어지며,
예상치 못한 부작용이 발생하여 디버깅을 매우 어렵게 만들 수 있다. 외부의 접근 권한이 필요하지 않은 모든 멤버 함수와 멤버 변수는 반드시 Private으로 선언해야하며, 상황에 따라 Default, Protected, Public을 제한적으로 사용해야한다.

간단히 정리하면, Default는 패키지 내의 유기적 연결을 위해 접근 허용이 필요한 경우, Protected는 상속 관계에서 유기적 연결을 위해 접근 허용이 필요한 경우, Public은 외부에서 해당 Class를 사용하기 위해 선언된 멤버 함수에만 사용되어야 한다.

## 2. 하나의 파일에는 하나의 Class만 작성한다.
FTC Robot Controller에서는 Java를 기반으로 여러 하드웨어 구성 요소를 클래스로 분리해 작성한다. 이때 하나의 .java 파일에는 하나의 클래스만 정의하는 것이 권장된다.

* __명확한 구조화__: FTC 프로젝트에서는 OpMode, MecanumDrive, Intake, Arm 등 기능별로 클래스를 나누어 구성하는 것이 일반적이다. 각 클래스를 별도의 파일로 관리하면 기능별 책임이 명확해지고, 구조를 파악하기 쉽다.
  
* __파일명과 클래스명의 일치__: Java에서는 public 클래스를 정의할 경우, 해당 클래스의 이름과 파일명이 반드시 같아야 한다. 이를 통해 코드 구조가 명확해지고, 클래스 위치를 쉽게 추적할 수 있다.

* __가독성과 유지보수성 향상__: 각 클래스가 별도의 파일에 존재하면, 클래스의 책임과 역할이 명확히 분리되고 코드가 더 이해하기 쉬워진다.

* __버전 관리 효율성__: 클래스별로 변경 사항을 관리할 수 있어 Git 등 버전 관리 시스템에서 충돌을 줄이고 추적이 용이하다.
  
*___OpMode 탐지 문제 방지__: 두 개 이상의 OpMode 클래스가 하나의 파일에 정의되어 있으면, FTC SDK가 해당 클래스를 제대로 인식하지 못할 수 있다. 이를 방지하기 위해서는 OpMode는 반드시 독립된 클래스/파일로 분리해야 한다.

각 Class는 이미 충분히 복잡한 기능 구현을 포함하고 있다. 여러 개의 Class가 하나의 파일에 정의되어 있으면 가독성이 떨어지고, 유지보수와 코드 작성 측면에서 많은 불편함이 따를 수 있다.
따라서 위와 같은 이유에 따라 TALOS 팀의 FTC Robot Controller 코드 작성 시에는 해당 규칙을 강제한다.

## 3. Subclass는 그 구조가 간단해야한다.
Subclass란 Class 안에 Class를 정의하는 형태를 의미한다. 이러한 방식은 "2. 하나의 파일에는 하나의 Class만 작성한다."와 같은 이유로 권장되지 않는다.
하지만, 벡터나 색상값 등 복잡한 구조의 다차원 데이터를 다루어야 하는 특수한 경우에는 이를 관리하기 위한 객체를 정의한다. 보통 이러한 Class 역시 독립적인 파일에 정의하는 것을 권장하지만,
이러한 객체가 해당 Class 내부에서만 사용되거나, 해당 Class에만 관련된 데이터 형식일 경우에는 독립적인 파일에 정의하는 것은 오히려 가독성을 떨어트리고, 코드의 복잡성을 늘리는 행위일 수 있다.
따라서 선술한 경우와 같이 해당 Class에만 지엽적으로 사용되는 특수한 경우에만 Subclass 제작이 허용된다.

단, Subclass는 그 존재 자체만으로 "2. 하나의 파일에는 하나의 Class만 작성한다."를 위반하는 내용이며, 해당 Class 전체의 복잡성을 증가시키고, 유지보수를 어렵게 만들 수 있다.
따라서 Subclass는 데이터 저장의 기능만 수행한다거나, 간단한 데이터 가공만을 하는 간결한 멤버 함수만 가지는 등 그 구조가 간단해야한다.

*ref : [FTC 2024-2025 Robot Controller for APOC](https://github.com/TALOS-25309/FTC2024-2025_RobotController_V2/blob/main/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/features/SmartGamepad.java) - Features / SmartGamepad*

## 4. 함수는 하나의 기능만 수행해야하며, 내용이 명확해야한다.

하나의 함수는 단일한 목적(Single Responsibility Principle) 을 가져야 하며, 그 기능이 명확히 정의되어 있어야 한다. 예를 들어, `moveToTarget()` 함수는 오직 로봇을 특정 위치로 이동시키는 역할만 수행해야 하며, 동시에 센서를 초기화하거나 경로를 기록하는 등의 복합적인 작업을 수행해서는 안 된다. 또한, 함수의 길이는 가능한 한 짧게 유지되어야 하며, 코드 흐름을 한눈에 파악할 수 있을 정도로 간결해야 한다.

* **가독성 향상**: 함수가 간결하고 하나의 목적만을 수행하면, 다른 개발자가 코드를 빠르게 이해하고 유지보수하기 쉬워진다.
  
* **재사용성 증가**: 기능이 분리되어 있으면 필요한 기능만 독립적으로 재사용하거나 테스트할 수 있다.
  
* **디버깅 용이**: 문제가 생겼을 때, 어떤 함수에서 어떤 문제가 발생했는지를 명확하게 파악할 수 있다.
  
* **로봇 동작 안정성 확보**: FTC Robot Controller는 실시간으로 다양한 이벤트를 처리해야 하므로, 각 함수가 명확하고 간단해야 로봇의 예측 가능한 동작을 보장할 수 있다.

```java
// 규칙 위반 사례
public void runAuto() {
    resetIMU();
    moveToPosition(30, 20);
    if (detectSample()) {
        pickUpSample();
        logData();
    }
}

// 규칙 준수 예시
public void runAuto() {
    initializeSensors();
    navigateToSample();
    handleSample();
}

private void initializeSensors() {
    resetIMU();
}

private void navigateToSample() {
    moveToPosition(30, 20);
}

private void handleSample() {
    if (detectSample()) {
        pickUpSample();
    }
}
```

이 규칙은 준수하고자 노력할 필요는 있지만, 상황에 따라 유연하게 활용할 필요가 있다. 이 규칙을 따르면 여러가지 이점이 있지만, 오히려 코드를 복잡하게 만들 수 도 있으며, 어떤 기능들은 부작용을 포함하므로써 더욱 고차원적이고 최적화된 움직임을 구현할 수 있기에, 어쩔 수 없이 이 규칙을 위반해야하는 경우도 존재한다. **이 규칙을 위반해야한다면, 프로그래머는 그 이유를 명확히 알고 행동해야하며, 이로 인해 만들어질 수 있는 버그에 각별히 신경 써야 한다. 또한, 각 함수의 역할을 정확히 파악하고 있어야 한다. 따라서 주석을 활용하여 각 함수의 부작용들을 서술해두면 도움이 될 수 있다.**

## 5. 상태를 저장하기 위해서는 상수 대신에 Enumeration을 활용한다.
상태 저장은 매우 중요하다. 로봇의 현재 상태를 적절히 나누고, 각 상태를 적절히 표현할 수 있다면, 비정상적인 움직임을 시스템적으로 제한할 수 있고, 독립된 동작을 연결 동작으로 자동화하여 로봇 조작을 더욱 간단하게 만들 수 있다.

각 상태를 저장할 때에는 상수 대신에 Enumeration을 활용한 명시적 저장을 권장한다. 왜냐하면, 상수를 활용할 경우 가독성이 매우 떨어지며, 실수로 인해 잘못된 판단 및 버그가 발생할 수 있기 때문이다.
Enumeration은 자연어를 활용한 상태 정의를 가능하게 하며, 이를 활용해 더욱 명확한 상태 정의 및 상태 기반 제어를 할 수 있다.

상태를 나누는 것 역시나 매우 중요하다. 상태를 불필요하게 세세하게 나누면, 상태 기반 제어에서 조건이 매우 길고 복잡하게 변할 수 있다.
반대로 상태를 너무 간단하게 나누면, 상태 기반 제어가 부정확해지고, 예상치 못한 작동이 발생할 수 있다.

이를 예방하기 위하여 상태는 상태 기반 제어를 고려하여 최소한으로 나누어야한다.

*ref : [FTC 2024-2025 Robot Controller for APOC](https://github.com/TALOS-25309/FTC2024-2025_RobotController_V2/tree/main/TeamCode/src/main/java/org/firstinspires/ftc/teamcode) - Part States & TeleOpMode State Based Control*

## 6. Sleep은 절대 사용하지 않는다.
Robot Controller를 만들다보면 특정 딜레이 이후 명령을 수행해야하는 경우가 있다. 일반적으로는 Sleep을 활용해서 딜레이를 넣지만, Robot Controller 개발을 할 때에는 절대 Sleep을 사용하면 안 된다.

로봇은 반복문 속에서 끊임없이 게임패드와 각종 센서의 상태를 확인하고, 이를 활용한 적절한 제어가 이루어져야한다. 하지만 Sleep 함수를 사용하여 딜레이를 넣는 순간, 그 딜레이 동안에는 모든 로봇 제어가 정지된다.
만약 로봇이 가만히 있는 상황이었다면 아무런 상관이 없겠으나, DC Motor가 돌아가고 있던 상황이아면, PID 제어 혹은 게임 패드 제어에 의거한 DC Motor 속도 조작이 중단되고, 멈추어햐 할 때 멈추지 않고 계속해서 움직이는 사고가 일어날 수 있다.
이는 로봇에 매우 심각한 손상을 일으킬 수 있는 중대한 버그이다. 

따라서 우리는 Sleep 함수를 사용하면 안 되며, 딜레이를 주어야 하는 경우, 딜레이 이후 실행할 명령을 함수형 프로그래밍 관점에서 함수 객체의 형태로 저장해두고 실행을 미루었다가,
내부적으로 타이머를 활용해서 주어진 딜레이에 해당하는 시간이 지난 시점을 지속적으로 검사하여, 특정 딜레이 이후에 해당 기능을 실행하는 방식으로 구현해야 한다. 
이 경우 타이머를 활용해 주어진 딜레이에 해당하는 시간이 지났는지 확인하는 동시에, 계속해서 반복문을 돌리며, 입력값에 대한 지속적인 출력값 피드백이 가능하다.

이 방식을 구현한 대표적인 방법이 바로 FTC 2024-2025 Into The Deep Season Robot Controller 코드의 Schedule 객체이다.
구현되어있는 코드를 직접 읽고 학습하여 그 구조를 파악하는 것을 권장한다.

또한, 이 방법을 응용하면, 딜레이 뿐만 아니라, 특정 조건을 만족했을 때 코드가 실행되도록 할 수도 있다.
이를 통해 딜레이 기반이 아니라, 동작 종료를 기반으로 한 실행을 통해 동작을 최적화할 수 있다.

*ref : [FTC 2024-2025 Robot Controller for APOC](https://github.com/TALOS-25309/FTC2024-2025_RobotController_V2/blob/main/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/features/Schedule.java) - Features / Schedule*

## 7. 동시성을 구현할 때에는 이벤트 기반 프로그래밍을 활용한다.
효율적인 로봇은 여러 가지 일을 동시에 처리할 수 있어야한다. 따라서 Robot Controller를 개발할 때에는 반드시 동시성 프로그래밍을 해야한다.

동시성 프로그래밍을 구현하기 위하여 Thread를 사용할 수도 있지만, 이는 매우 부적합하며 위험하다.
Thread의 가장 큰 위험 요소는 자원에 대한 동시 접근이다. 이를 방지하여 Thread-safe를 달성하기 위해서는 각 자원에 대한 원자적 수정을 보장하거나, mutex를 사용한 상호 배제를 구현해야 하지만 이것은 매우 어려운 문제이다. 
특히, 로봇은 하드웨어에 빈번하게 접근하여 통신해야 하기에, Thread의 공유 데이터 처리와는 다르게 훨씬 복잡하며, 어찌저찌 안전한 시스템을 만들더라도 오버헤드로 인하여 효율이 굉장히 떨어질 것이다.

따라서 프로그래머가 제어하기 쉽고 안전하며, 오버헤드 최적화가 비교적 쉬운 **이벤트 기반 프로그래밍**을 적극적으로 권장한다.
이 내용은 "6. Sleep은 절대 사용하지 않는다."에서 Sleep을 쓰지 않고 지연된 움직임을 구현하는 방법에 관한 것과 어느 정도 관련된 이야기로, Schedule 객체를 활용한 지연 움직임 구현 방법이 일종의 이벤트 기반 프로그래밍이다.

## 8. 수치들은 단위를 통일한다.
로봇 제어 코드에서 사용하는 모든 수치는 일관된 단위 체계를 따라야 한다. Java 코드 내 상수, 함수 인자, 반환값 등 모든 수치 데이터는 같은 기준으로 처리되어야 하며, 단위 변환이 필요한 경우 반드시 명시적으로 변환을 수행해야 한다.

예를 들어 거리를 나타내기 위해서 우리는 mm를 주로 사용하지만, 리니어 슬라이드를 활용한다면 엔코더 값이 길이에 해당한다. 또한, 각도 역시 우리는 도 단위가 다루기 편하지만, 삼각법 계산을 활용하기 위해서는 라디안을 쓰는 것이 유리하다.
이렇게 다양한 단위를 사용하면 단위를 실수하여 값 처리를 잘못 수행하여 로봇의 움직임이 비정상적으로 동작할 수 있으며, 디버깅과 공동 개발의 난이도를 높이는 원인이 될 수 있다.

따라서 Robot Controller 소스코드에서 다루는 다양한 값들은 단위를 통일해두는 것을 권장하며, 변수명 등을 활용해 그 단위를 명확히 표현하는 것을 권장한다. 또한, 변환 함수를 제작하여 단위 변환이 간단하게 이루어질 수 있도록 해야하며, 단위 변환은 해당 단위가 필요한 적절한 시점에만 이루어져야한다.

## 9. 수식은 코드로 바로 작성하지 않는다.
수학적인 계산에 근거하여 로봇을 조작하면 훨씬 정교하고 체계적인 로봇 움직임을 구현할 수 있다. 하지만, 수식을 세울 때에는 계산 실수 등이 포함될 수 있으며, 잘못 작성된 수식을 디버깅 하는 것은 비교적 어렵기에 주의가 필요한다.

특히, 머릿속으로 계산한 후, 이를 바로 코드로 옮기는 것은 매우 권장되지 않는다. 코드로 작성된 수식은 검산에 매우 불리하기 때문이다. 
코드로 작성된 수식은 그 형태가 명확하지 않을 뿐더러, 제약 조건이 추가되거나, 여러 가지 단위가 섞여 쓰이는 순간 그 복잡성이 기하급수적으로 상승한다.
따라서 수식을 세울 때에는 우선 수학적으로 수식을 기술해야하며, 그림 등을 활용하여 완전한 검산을 완료한 후, 문제가 없는 수식이 완성된 후에야 이를 코드로 옮겨야한다.

## 10. Telemetry를 활용한 값 출력은 코드 어디서든 가능해야한다.
Robot Controller를 디버깅 하는 것은 다른 프로그램들에 비해 매우 어렵다.
왜냐하면, 모든 버그는 로봇의 동작에 기반하여 찾아야하며, 그 버그의 원인은 복잡한 코드 구조와 다양한 환경적 요인이 복합적으로 작용하기에, 문제의 원인이 될 수 있는 요인들이 매우 다양하고, 원인이 매우 복잡할 수 있기 떄문이다.
또한, 다른 프로그램과 다르게 디버깅 툴은 절대 사용할 수 없으며, 활용할 수 있는 것은 출력값과 로봇의 움직임 뿐이지만, 로봇의 움직임을 디버깅에 활용하는 것은 자칫 비정상적인 움직임으로 로봇이 손상될 수 있기에 매우 위험하다.
따라서 우리가 활용할 수 있는 유일한 디버깅 도구는 Telemetry 출력값이다.

버그가 발견되면, 우리는 Telemetry 출력을 기반으로 버그의 원인을 찾아야한다. 이것이 가장 빠르고 명확한 원인 파악 방법이다.
출력을 통해 잘못된 부분의 위치와 값을 파악할 수 있다. 따라서 우리는 코드의 어디서는 Telemetry를 활용한 값 출력이 가능해야한다.

이를 달성하기 위하여 보통 Telemetry를 Public Static Memory 영역에 저장하여, 어디서든 접근할 수 있도록 한다.

디버깅을 하는 과정을 보통 아래와 같이 이루어진다.
1. 로봇의 비정상적인 움직임으로부터 버그의 존재 확인
2. 버그의 원인이 될 만한 요소 파악, 이 부분은 프로그래머의 능력에 달려있음
3. 코드를 검토하며 버그 요인을 확인하고, 버그를 수정
4. 디버깅 후 테스트
5. 원인이 아닌 경우에는 다른 원인을 생각해보고, 코드를 검토하고, 버그를 수정
6. 버그의 원인이 파익되지 않는 경우, 의심되는 값을 Telemetry를 통해 출력해보거나, 실행되는지 의심이 되는 부분에 Telemetry 출력을 넣어 실행 여부를 확인
7. Telemetry 출력을 기반으로 로봇 움직임으로 드러나지 않는 비정상적인 코드 흐름을 명확히 파악하여 버그의 원인을 구체화
8. 버그의 원인을 생각해보고, 코드를 검토하여 버그를 수정

참고로 Telemetry는 Update 될 때, 과거에 출력된 내용이 삭제된다. 따라서 매 사이클마다 출력이 있는게 아니라면 Driver Hub 상에서는 Telemetry 출력이 표시되지 않을 수 있다.
이 경우에는 FTC Dashboard를 사용하면 된다. FTC Dashboard는 Caption 기준으로 Caption이 같은 출력만 덮어쓰고, 그렇지 않은 출력은 이번 사이클에 출력되지 않더라도 이전 사이클에 출력됐으면 그 기록이 계속 남아있다.
따라서 FTC Dashboard를 사용하면 출력이 됐는지 안 됐는지 좀 더 명확하게 파악할 수 있다.

## 11. Git & Github을 활용한 버전 관리를 체계적으로 수행한다.
Robot Controller는 혼자 개발하는 것이 아니다. 여러명의 프로그래머가 업무를 분담하여 하나의 Robot Controller를 개발해야한다.
코드를 효과적으로 공유하고, 병합하기 위하여 Github을 주로 활용하기에, TALOS 팀의 모든 프로그래머는 Git과 Github에 익숙해야하며, 이를 잘 활용할 수 있어야한다.

또한, 예측 불가능한 로봇 프로그램을 개발하는 만큼 다양한 접근을 해야하고, 그만큼 코드를 롤백해야할 일도 빈번한다.
따라서 무언가 변경 사항이 생기면 지체 없이 이를 Commit하여 기록을 남겨두어야 한다.
Commit 없이 코드를 수정했다가 다시 롤백해야할 상황이 오면, 그 자체로 프로그래머에게는 큰 스트레스일 뿐더러, 롤백 과정에서 실수가 발생하면 또 다른 버그로 이어져 시간을 낭비하게 될 수 있다.

Commit 로그를 작성할 때에는 수정 사항이 명확히 드러나도록 작성해야한다. 
변경 사항을 한 눈에 알아볼 수 있도록 함으로써, 다른 프로그래머들에게 자신이 개발한 내용을 명확히 이해시키고, 이전 버전으로 돌아가야할 일이 생겼을 때 실수를 최소화 할 수 있다.
특히, 요즘에는 Github Copilot이 자동으로 Commit Log를 작성해주는 기능이 생겼으니, 이용해보길 바란다.
